### Introduction
This whitepaper is an attempt to assist the architect and developer community who are coming from a “traditional” deployment setup (data center deployment, 3-tier, monolithic, single stack etc.) and now want to build modern applications that can scale on demand, remain resilient under duress and ultimately enable business to achieve their goals. In recent years, there is now general agreement on the typical characteristics of such architectures. Most of them will be deployed in a public or private cloud, heavily leverage cloud-native or open-source technologies and have significantly accelerated development lifecycles. To enable these, applications need to be built from ground up to effectively leverage and compensate for the cloud platform aka the Cloud native architecture. 
For an architect who has a background in building more “traditional” applications, these modern architectures pose a substantial challenge. Some of the key reasons are listed below:

* Traditionally, the role of an architect was confined to application architecture, while the platform deployment was the responsibility of separate dedicated teams. The new way of working has been the transition from the “application” mode to “product” mode where a single lean team is responsible for building, running, fixing and securing the product. Additionally, with the transition to cloud technology, much of the “infrastructure” concerns that was earlier the domain of infra teams have fallen under the ambit of an architect.
*	While the raison d'etre of any product is to provide some useful function to the user, developing the compute is now perhaps the easier part of the architect’s job. The concerns surrounding the business logic will now take up more of the working hours to build and manage. This is arguably due to the managed nature of the cloud (ephemeral instances, multiple components, limited visibility etc.) where substantial responsibility is now assigned to the architect to effectively compensate for the cloud. 
*	The speed of execution expected by business and inherent platform complexity leaves a developer no choice but to opt for complete automation of build, test and deployment cycle. This forces the developer to think in terms of “code” not just for building the business logic but also the deployment and infra provisioning process.

All the above reasons has increased the profile and competencies expected for a “full-stack” architect where full-stack means the ability to understand tradeoffs of programming languages, be comfortable with cloud technologies, traverse between application and infra domains and in general be able to switch between macro and micro considerations. 
Even though there are ample blogs, tutorials, and documentation available that attempt to clarify these topics, for a newbie architect trying to digest this overdose of information is a real challenge. This whitepaper attempts to bridge this gap. This whitepaper will be most useful when used to analyze the reasoning and tradeoffs of an existing cloud-native architecture or used as a pattern recipe while designing a new architecture.

*Intended audience*: Developers, Cloud engineers, System Architects, Product owners

[Next- Architecture Goals](https://github.com/srikanthkotekar/ideasworthsharing/blob/master/Building-Modern-Cloud-Native-Apps/3.%20Architecture%20Goals%20(Key%20Drivers).md)
